---
import Avatar from "@/assets/avatar.svg";
import { getI18N } from "@/i18n";

const { currentLocale } = Astro;
const i18n = getI18N({ currentLocale });
const messagesArr = i18n.CHARACTER.MESSAGES;
---

<div class="float-shape" data-messages={JSON.stringify(messagesArr)}></div>
<button class="bio-image" transition:name="character">
    <Avatar />
</button>

<script>
    import { gsap } from "gsap";
    import { TextPlugin } from "gsap/TextPlugin";

    gsap.registerPlugin(TextPlugin);

    // ============================================================================
    // CONSTANTS
    // ============================================================================

    const CONFIG = {
        typingSpeed: 0.04,
        readingTime: 2000,
        blinkInterval: [2000, 6000],
        mouseRange: 500,
        maxRotation: 15,
    };

    // ============================================================================
    // POSITIONING (Sticky + Boundary)
    // ============================================================================

    function syncPosition(container: HTMLElement, bioImage: HTMLElement) {
        const rect = container.getBoundingClientRect();
        const parent = container.parentElement;
        if (!parent) return;

        const parentRect = parent.getBoundingClientRect();

        let top = Math.max(0, rect.top); // Sticky at top
        top = Math.min(top, parentRect.bottom - rect.height); // Keep in parent

        const breakpointTop = 25;

        if (rect.top < breakpointTop - 50) {
            top = breakpointTop;
        }
        const right = window.innerWidth - rect.right;
        gsap.set(bioImage, {
            top,
            right: top === breakpointTop ? right / 1.5 : right,
            width: top === breakpointTop ? 75 : rect.width,
            height: top === breakpointTop ? 75 : rect.height,
        });
    }

    function setupPositioning(container: HTMLElement, bioImage: HTMLElement) {
        const sync = () => syncPosition(container, bioImage);

        // Initial sync
        sync();

        // Only sync on scroll and resize, not every frame
        let rafId: number | null = null;

        const scheduleSync = () => {
            if (rafId === null) {
                rafId = requestAnimationFrame(() => {
                    sync();
                    rafId = null;
                });
            }
        };

        window.addEventListener("scroll", scheduleSync, { passive: true });
        window.addEventListener("resize", scheduleSync);

        // Cleanup
        const cleanup = () => {
            window.removeEventListener("scroll", scheduleSync);
            window.removeEventListener("resize", scheduleSync);
            if (rafId !== null) cancelAnimationFrame(rafId);
        };

        document.addEventListener("astro:before-preparation", cleanup);

        return cleanup;
    }

    // ============================================================================
    // BLINK ANIMATION
    // ============================================================================

    function startBlinking(eyes: HTMLElement[]) {
        function scheduleBlink() {
            const [min, max] = CONFIG.blinkInterval;
            const delay = (Math.random() * (max - min) + min) / 1000;

            gsap.delayedCall(delay, () => {
                gsap.timeline()
                    .to(eyes, { opacity: 0, duration: 0.08, ease: "power2.in" })
                    .to(eyes, {
                        opacity: 1,
                        duration: 0.08,
                        ease: "power2.out",
                    });
                scheduleBlink();
            });
        }
        scheduleBlink();
    }

    // ============================================================================
    // SPEECH BUBBLE
    // ============================================================================

    function createBubble() {
        const bubble = document.createElement("div");
        bubble.className = "speech-bubble";

        Object.assign(bubble.style, {
            position: "absolute",
            bottom: "100%",
            left: "50%",
            marginBottom: "15px",
            transform: "translateX(-50%)",
            backgroundColor: "#fff",
            color: "#111",
            padding: "12px 18px",
            borderRadius: "18px",
            fontSize: "14px",
            fontWeight: "600",
            boxShadow: "0 4px 12px rgba(0,0,0,0.15)",
            zIndex: "9",
            whiteSpace: "pre-wrap",
            textAlign: "center",
            lineHeight: "1.4",
            maxWidth: "240px",
            minWidth: "120px",
        });

        const text = document.createElement("div");
        text.style.minHeight = "1.4em";
        bubble.appendChild(text);

        const tail = document.createElement("div");
        Object.assign(tail.style, {
            position: "absolute",
            top: "100%",
            left: "50%",
            marginLeft: "-12px",
            borderStyle: "solid",
            borderWidth: "12px 12px 0 12px",
            borderColor: "#fff transparent transparent transparent",
        });
        bubble.appendChild(tail);

        gsap.set(bubble, { scale: 0, y: 10, opacity: 0 });

        return { bubble, text };
    }

    function setupSpeechBubble(bioImage: HTMLElement, messages: string[]) {
        let bubble: HTMLDivElement | null = null;
        let text: HTMLDivElement | null = null;
        let currentIndex = 0;
        let hideTimeout: number | null = null;
        let isVisible = false;
        let timeline: GSAPTimeline | null = null;

        function show(message: string) {
            if (!bubble || !text) return;

            isVisible = true;
            timeline?.kill();

            timeline = gsap.timeline();
            timeline
                .to(bubble, {
                    scale: 1,
                    y: 0,
                    opacity: 1,
                    duration: 0.4,
                    ease: "back.out(1.7)",
                })
                .to(
                    text,
                    {
                        duration: message.length * CONFIG.typingSpeed,
                        text: { value: message, delimiter: "" },
                        ease: "none",
                    },
                    "<",
                );

            // Auto-hide after typing + reading
            const delay =
                message.length * CONFIG.typingSpeed * 1000 + CONFIG.readingTime;
            hideTimeout = window.setTimeout(hide, delay);
        }

        function hide(callback?: () => void) {
            if (!bubble || !text) return;

            isVisible = false;
            timeline?.kill();
            gsap.killTweensOf(text);

            timeline = gsap.timeline({ onComplete: callback }).to(bubble, {
                scale: 0.8,
                y: -5,
                opacity: 0,
                duration: 0.3,
                ease: "power2.in",
            });
        }

        function handleClick(e: Event) {
            e.stopPropagation();

            // Create bubble on first click
            if (!bubble) {
                const created = createBubble();
                bubble = created.bubble;
                text = created.text;
                bioImage.appendChild(bubble);
            }

            if (hideTimeout) clearTimeout(hideTimeout);

            if (isVisible) {
                // Cycle to next message
                hide(() => {
                    currentIndex = (currentIndex + 1) % messages.length;
                    show(messages[currentIndex]);
                });
            } else {
                show(messages[currentIndex]);
            }
        }

        return handleClick;
    }

    // ============================================================================
    // MOUSE TRACKING
    // ============================================================================

    function setupMouseTracking(bioImage: HTMLElement, svg: SVGElement) {
        function handleMove(e: MouseEvent | PointerEvent) {
            const rect = bioImage.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            // Normalize mouse position (-1 to 1)
            const normX = Math.max(
                -1,
                Math.min(1, (e.clientX - centerX) / CONFIG.mouseRange),
            );
            const normY = Math.max(
                -1,
                Math.min(1, (e.clientY - centerY) / CONFIG.mouseRange),
            );

            gsap.to(svg, {
                rotateY: normX * CONFIG.maxRotation,
                rotateX: -normY * CONFIG.maxRotation,
                translateX: normX * 8,
                duration: 0.0001,
                ease: "power2.out",
                overwrite: "auto",
            });
        }

        function handleLeave() {
            gsap.to(svg, {
                rotateY: -10,
                rotateX: 0,
                translateX: -5,
                duration: 1,
                ease: "elastic.out(1, 0.5)",
            });
        }

        window.addEventListener("pointermove", handleMove);
        bioImage.addEventListener("mouseleave", handleLeave);
    }

    // ============================================================================
    // INITIALIZATION
    // ============================================================================

    function initCharacter(container: HTMLElement) {
        const bioImage = container.nextElementSibling as HTMLElement;
        if (!bioImage?.classList.contains("bio-image")) return;

        const svg = bioImage.querySelector("svg") as SVGElement;
        if (!svg) return;

        // Parse messages
        const messagesJSON = container.getAttribute("data-messages");
        const messages: string[] = messagesJSON
            ? JSON.parse(messagesJSON)
            : ["Â¡Hola!"];

        // 1. Positioning
        setupPositioning(container, bioImage);

        // 2. Blinking
        const eyeLeft = svg.querySelector("#eye-open-left") as HTMLElement;
        const eyeRight = svg.querySelector("#eye-open-right") as HTMLElement;
        if (eyeLeft && eyeRight) {
            startBlinking([eyeLeft, eyeRight]);
        }

        // 3. Speech bubble
        const handleClick = setupSpeechBubble(bioImage, messages);
        bioImage.addEventListener("pointerdown", handleClick);
        svg.addEventListener("pointerdown", handleClick);
        bioImage.addEventListener("touchend", (e) => {
            e.preventDefault();
            handleClick(e);
        });

        // 4. Mouse tracking
        setupMouseTracking(bioImage, svg);
    }

    function initAll() {
        document
            .querySelectorAll<HTMLElement>(".float-shape")
            .forEach((container) => {
                if (!container.dataset.initialized) {
                    container.dataset.initialized = "true";
                    initCharacter(container);
                }
            });
    }

    document.addEventListener("DOMContentLoaded", initAll);
    document.addEventListener("astro:page-load", initAll);
</script>

<style>
    .float-shape {
        float: right;
        padding: 0;
        min-height: 50%;
        width: 140px;
        height: 140px;
    }

    .bio-image {
        padding: 0;
        transition:
            transform 0.3s ease,
            width 0.3s ease,
            height 0.3s ease,
            right 0.1s ease,
            top 0s ease;
        perspective: 100px;
        transform-style: preserve-3d;
        display: flex;
        justify-content: center;
        align-items: center;
        user-select: none;
        height: 140px;
        width: 140px;
        position: fixed;
        z-index: 2;
        pointer-events: none;
        transform-origin: bottom center;
        animation: 8s ease-out 0s infinite sway;
    }

    @keyframes sway {
        0%,
        10%,
        100% {
            transform: rotate(0deg);
        }
        2% {
            transform: rotate(-6deg);
        }
        4% {
            transform: rotate(6deg);
        }
        6% {
            transform: rotate(-3deg);
        }
        8% {
            transform: rotate(2deg);
        }
    }

    svg {
        cursor: pointer;
        user-select: none;
        transition: transform 0.3s ease;
        height: max-content;
        width: 100%;
        transform: rotateY(-10deg) translateX(-5px);
        pointer-events: auto;
        max-width: 100%;

        &:hover {
            transform: rotateY(0deg) scale(1.15) translateX(0px);
        }
    }

    @media (width <= 1000px) {
        .bio-image {
            width: 120px;
        }
    }
    html.dark .bio-image {
        /* filter: contrast(1.5); */
    }
</style>
