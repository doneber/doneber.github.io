---
import Avatar from "@/assets/avatar.svg";
import { getI18N } from "@/i18n";

const { currentLocale } = Astro;
const i18n = getI18N({ currentLocale });
const messagesArr = i18n.CHARACTER.MESSAGES;
---

<astro-character
    class="character-container"
    data-messages={JSON.stringify(messagesArr)}
>
    <div class="float-shape"></div>

    <button
        class="bio-image"
        aria-label="Character Avatar: Click to hear me speak"
        transition:name="character"
    >
        <Avatar />

        <div class="speech-bubble" aria-live="polite" aria-hidden="true">
            <span class="bubble-text"></span>
            <div class="bubble-tail"></div>
        </div>
    </button>
</astro-character>

<script>
    import { gsap } from "gsap";
    import { TextPlugin } from "gsap/TextPlugin";

    gsap.registerPlugin(TextPlugin);

    class AstroCharacter extends HTMLElement {
        private ctx: gsap.Context | null = null;
        private messages: string[];
        private currentIndex: number = 0;
        private hideTimer: number | null = null;
        private isSpeaking: boolean = false;

        // DOM Elements
        private bioImage: HTMLElement;
        private svg: SVGElement;
        private bubble: HTMLElement;
        private bubbleText: HTMLElement;
        private floatShape: HTMLElement;

        // Constants
        private CONFIG = {
            typingSpeed: 0.04,
            readingTime: 2000,
            blinkInterval: [2000, 6000],
            mouseRange: 500,
            maxRotation: 15,
            stickyTop: 25,
            shrunkSize: 75,
        };

        constructor() {
            super();
            this.messages = JSON.parse(this.dataset.messages || '["..."]');
        }

        connectedCallback() {
            // Select elements scoped to this component
            this.bioImage = this.querySelector(".bio-image")!;
            this.svg = this.querySelector("svg")!;
            this.bubble = this.querySelector(".speech-bubble")!;
            this.bubbleText = this.querySelector(".bubble-text")!;
            this.floatShape = this.querySelector(".float-shape")!;

            // Initialize GSAP Context for easy cleanup
            this.ctx = gsap.context(() => {
                this.initBlinking();
                // We don't init mouse tracking here to avoid constant listeners on mobile
                // Instead we add them conditionally or keep them purely managed
            }, this);

            // 1. Positioning (Scroll/Resize)
            this.setupPositioning();

            // 2. Mouse Tracking
            this.setupMouseTracking();

            // 3. Interaction (Click/Touch)
            this.bioImage.addEventListener(
                "pointerdown",
                this.handleInteraction,
            );
            this.bioImage.addEventListener(
                "keydown",
                this.handleKeyInteraction,
            );
        }

        disconnectedCallback() {
            this.ctx?.revert();
            window.removeEventListener("scroll", this.onScroll);
            window.removeEventListener("resize", this.onScroll);

            this.bioImage.removeEventListener(
                "pointerdown",
                this.handleInteraction,
            );
            this.bioImage.removeEventListener(
                "keydown",
                this.handleKeyInteraction,
            );

            if (this.hideTimer) clearTimeout(this.hideTimer);
        }

        // =================================================================
        // 1. POSITIONING LOGIC (Restored Full Math)
        // =================================================================

        private onScroll = () => {
            // Throttle via rAF
            requestAnimationFrame(() => this.syncPosition());
        };

        private setupPositioning() {
            window.addEventListener("scroll", this.onScroll, { passive: true });
            window.addEventListener("resize", this.onScroll);
            // Initial sync
            this.syncPosition();
        }

        private syncPosition() {
            if (!this.floatShape || !this.parentElement) return;

            const rect = this.floatShape.getBoundingClientRect();
            const parentRect = this.parentElement.getBoundingClientRect();

            // Calculate sticky top position
            let top = Math.max(0, rect.top);

            // Constrain to parent bottom
            // Note: rect.height is the spacer height (140px)
            top = Math.min(top, parentRect.bottom - rect.height);

            const isSticky = rect.top < this.CONFIG.stickyTop - 50;

            // If sticky, we snap to specific top value
            if (isSticky) {
                top = this.CONFIG.stickyTop;
            }

            // Calculate Right position
            const right = window.innerWidth - rect.right;
            const targetRight = isSticky ? right / 1.5 : right;

            // Calculate Size
            const targetSize = isSticky ? this.CONFIG.shrunkSize : rect.width;

            gsap.set(this.bioImage, {
                top: top,
                right: targetRight,
                width: targetSize,
                height: targetSize,
            });
        }

        // =================================================================
        // 2. SPEECH BUBBLE LOGIC
        // =================================================================

        private handleKeyInteraction = (e: KeyboardEvent) => {
            if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                this.handleInteraction(e);
            }
        };

        private handleInteraction = (e: Event) => {
            e.stopPropagation();

            if (this.hideTimer) clearTimeout(this.hideTimer);

            const showNextMessage = () => {
                const msg = this.messages[this.currentIndex];
                this.currentIndex =
                    (this.currentIndex + 1) % this.messages.length;
                this.animateBubbleShow(msg);
            };

            if (this.isSpeaking) {
                // If already speaking, hide first, then show next
                this.animateBubbleHide(showNextMessage);
            } else {
                showNextMessage();
            }
        };

        private animateBubbleShow(message: string) {
            this.isSpeaking = true;
            this.bubble.setAttribute("aria-hidden", "false");

            // Ensure context is active so we can kill these tweens later
            this.ctx?.add(() => {
                const tl = gsap.timeline();

                tl.to(this.bubble, {
                    scale: 1,
                    y: 0,
                    opacity: 1,
                    duration: 0.4,
                    ease: "back.out(1.7)",
                }).to(
                    this.bubbleText,
                    {
                        duration: message.length * this.CONFIG.typingSpeed,
                        text: { value: message, delimiter: "" },
                        ease: "none",
                    },
                    "<",
                );

                // Auto-hide
                const delay =
                    message.length * this.CONFIG.typingSpeed * 1000 +
                    this.CONFIG.readingTime;
                this.hideTimer = window.setTimeout(() => {
                    this.animateBubbleHide();
                }, delay);
            });
        }

        private animateBubbleHide(onComplete?: () => void) {
            this.ctx?.add(() => {
                gsap.to(this.bubble, {
                    scale: 0.8,
                    y: -5,
                    opacity: 0,
                    duration: 0.3,
                    ease: "power2.in",
                    onComplete: () => {
                        this.isSpeaking = false;
                        this.bubbleText.innerText = "";
                        this.bubble.setAttribute("aria-hidden", "true");
                        if (onComplete) onComplete();
                    },
                });
            });
        }

        // =================================================================
        // 3. EYE BLINKING
        // =================================================================

        private initBlinking() {
            const leftEye = this.svg.querySelector("#eye-open-left");
            const rightEye = this.svg.querySelector("#eye-open-right");

            if (!leftEye || !rightEye) return;
            const eyes = [leftEye, rightEye];

            const blink = () => {
                const [min, max] = this.CONFIG.blinkInterval;
                const delay = (Math.random() * (max - min) + min) / 1000;

                gsap.delayedCall(delay, () => {
                    if (!this.isConnected) return;

                    const tl = gsap.timeline({ onComplete: blink });
                    tl.to(eyes, {
                        opacity: 0,
                        duration: 0.08,
                        ease: "power2.in",
                    }).to(eyes, {
                        opacity: 1,
                        duration: 0.08,
                        ease: "power2.out",
                    });
                });
            };

            blink();
        }

        // =================================================================
        // 4. MOUSE TRACKING & SWAY
        // =================================================================

        private setupMouseTracking() {
            // Mouse Move
            const handleMove = (e: PointerEvent | MouseEvent) => {
                const rect = this.bioImage.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                const normX = Math.max(
                    -1,
                    Math.min(1, (e.clientX - centerX) / this.CONFIG.mouseRange),
                );
                const normY = Math.max(
                    -1,
                    Math.min(1, (e.clientY - centerY) / this.CONFIG.mouseRange),
                );

                gsap.to(this.svg, {
                    rotateY: normX * this.CONFIG.maxRotation,
                    rotateX: -normY * this.CONFIG.maxRotation,
                    translateX: normX * 8,
                    duration: 0.5,
                    ease: "power2.out",
                    overwrite: "auto",
                });
            };

            // Mouse Leave (Elastic Reset)
            const handleLeave = () => {
                gsap.to(this.svg, {
                    rotateY: -10, // Default slightly turned
                    rotateX: 0,
                    translateX: -5,
                    duration: 1,
                    ease: "elastic.out(1, 0.5)",
                    overwrite: "auto",
                });
            };

            // Add listeners
            window.addEventListener("pointermove", handleMove);
            this.bioImage.addEventListener("mouseleave", handleLeave);

            // Cleanup specifically for these listeners
            // (We attach them to the instance so we can remove them later)
            // Note: Since 'handleMove' is an arrow function created here,
            // we need to store it to remove it.
            // Ideally, define these as class methods if you want perfect cleanup,
            // but for this scope, we can add them to the disconnect logic if we store references.

            // Re-assigning to class properties for cleanup access:
            this._handleMove = handleMove;
            this._handleLeave = handleLeave;
        }

        // Private refs for listener cleanup
        private _handleMove: any;
        private _handleLeave: any;
    }

    customElements.define("astro-character", AstroCharacter);
</script>

<style>
    .character-container {
        display: contents;
    }

    .float-shape {
        float: right;
        padding: 0;
        min-height: 50%; /* From original */
        width: 140px;
        height: 140px;
        shape-outside: circle(50%);
    }

    .bio-image {
        padding: 0;
        /* Transitions for sticky movement */
        transition:
            width 0.3s ease,
            height 0.3s ease;
        perspective: 100px;
        transform-style: preserve-3d;
        display: flex;
        justify-content: center;
        align-items: center;
        user-select: none;
        height: 140px;
        width: 140px;
        position: fixed; /* Fixed is required for the sticky logic provided */
        z-index: 50;
        background: transparent;
        border: none;
        cursor: pointer;
        transform-origin: bottom center;

        /* Passive Sway Animation */
        animation: sway 8s ease-out 0s infinite;
    }

    @keyframes sway {
        0%,
        10%,
        100% {
            transform: rotate(0deg);
        }
        2% {
            transform: rotate(-6deg);
        }
        4% {
            transform: rotate(6deg);
        }
        6% {
            transform: rotate(-3deg);
        }
        8% {
            transform: rotate(2deg);
        }
    }

    /* SVG Logic */
    :global(.bio-image svg) {
        width: 100%;
        height: max-content;
        max-width: 100%;
        transform: rotateY(-10deg) translateX(-5px); /* Default posture */
        transition: transform 0.3s ease;
        pointer-events: none; /* Let clicks pass to button */
    }

    /* Speech Bubble */
    .speech-bubble {
        position: absolute;
        bottom: 100%;
        left: 50%;
        margin-bottom: 15px;
        transform: translateX(-50%) scale(0);
        opacity: 0;

        background-color: #fff;
        color: #111;
        padding: 12px 18px;
        border-radius: 18px;
        font-size: 14px;
        font-weight: 600;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 9;
        white-space: pre-wrap;
        text-align: center;
        line-height: 1.4;
        max-width: 240px;
        min-width: 120px;
        pointer-events: none;
    }

    .bubble-tail {
        position: absolute;
        top: 100%;
        left: 50%;
        margin-left: -12px;
        border-style: solid;
        border-width: 12px 12px 0 12px;
        border-color: #fff transparent transparent transparent;
    }

    @media (width <= 1000px) {
        .bio-image {
            width: 120px;
        }
    }
</style>
