---
import Avatar from "@/assets/avatar.svg";
import { getI18N } from "@/i18n";

const { currentLocale } = Astro;
const i18n = getI18N({ currentLocale });
const messagesArr = i18n.CHARACTER.MESSAGES;
---

<div class="bio-image-container" data-messages={JSON.stringify(messagesArr)}>
    <div class="bio-image">
        <Avatar />
    </div>
</div>

<script>
    import { gsap } from "gsap";
    import { TextPlugin } from "gsap/TextPlugin";

    gsap.registerPlugin(TextPlugin);

    interface BubbleState {
        element: HTMLDivElement | null;
        textElement: HTMLDivElement | null;
        hideTimeout: number | null;
        currentMessageIndex: number;
        isVisible: boolean;
        timeline: GSAPTimeline | null;
        isTyping: boolean;
    }

    function initCharacter(container: HTMLElement) {
        const svg = container.querySelector(".bio-image svg") as SVGElement;
        if (!svg) return;

        // --- Blink Logic ---
        const eyeLeft = svg.querySelector("#eye-open-left") as HTMLElement;
        const eyeRight = svg.querySelector("#eye-open-right") as HTMLElement;

        if (eyeLeft && eyeRight) {
            const blink = () => {
                const tl = gsap.timeline();
                tl.to([eyeLeft, eyeRight], {
                    opacity: 0,
                    duration: 0.08,
                    ease: "power2.in",
                }).to([eyeLeft, eyeRight], {
                    opacity: 1,
                    duration: 0.08,
                    ease: "power2.out",
                });
            };

            const scheduleBlink = () => {
                const randomDelay = Math.random() * 4000 + 2000;
                gsap.delayedCall(randomDelay / 1000, () => {
                    blink();
                    scheduleBlink();
                });
            };

            scheduleBlink();
        }

        // --- Speech Bubble Logic ---
        const state: BubbleState = {
            element: null,
            textElement: null,
            hideTimeout: null,
            currentMessageIndex: 0,
            isVisible: false,
            timeline: null,
            isTyping: false,
        };

        const messagesJSON = container.getAttribute("data-messages");
        const messages: string[] = messagesJSON
            ? JSON.parse(messagesJSON)
            : ["¡Hola!"];

        function createBubbleElement(): HTMLDivElement {
            const bubble = document.createElement("div");
            bubble.className = "speech-bubble";

            Object.assign(bubble.style, {
                position: "absolute",
                bottom: "100%",
                left: "50%",
                marginBottom: "15px",
                transform: "translateX(-50%)",
                backgroundColor: "#fff",
                color: "#111",
                padding: "12px 18px",
                borderRadius: "18px",
                fontSize: "14px",
                fontWeight: "600",
                boxShadow: "0 4px 12px rgba(0,0,0,0.15)",
                zIndex: "9",
                whiteSpace: "pre-wrap",
                opacity: "0",
                pointerEvents: "none",
                textAlign: "center",
                lineHeight: "1.4",
                maxWidth: "240px",
                minWidth: "120px",
                wordWrap: "break-word",
            } as Partial<CSSStyleDeclaration>);

            const textElement = document.createElement("div");
            textElement.style.minHeight = "1.4em";
            bubble.appendChild(textElement);

            const tail = document.createElement("div");
            Object.assign(tail.style, {
                position: "absolute",
                top: "100%",
                left: "50%",
                marginLeft: "-12px",
                width: "0",
                height: "0",
                borderStyle: "solid",
                borderWidth: "12px 12px 0 12px",
                borderColor: "#fff transparent transparent transparent",
                zIndex: "1",
            } as Partial<CSSStyleDeclaration>);

            bubble.appendChild(tail);

            gsap.set(bubble, {
                scale: 0,
                y: 10,
                opacity: 0,
            });

            state.textElement = textElement;
            return bubble;
        }

        function typeMessage(message: string): void {
            if (!state.textElement || !state.element) return;
            state.isTyping = true;
            state.textElement.textContent = "";
            const baseSpeed = 0.04;
            const duration = message.length * baseSpeed;

            gsap.to(state.textElement, {
                duration: duration,
                text: {
                    value: message,
                    delimiter: "",
                },
                ease: "none",
                onComplete: () => {
                    state.isTyping = false;
                },
            });
        }

        function showBubble(message: string): void {
            if (!state.element) return;
            state.isVisible = true;
            if (state.timeline) state.timeline.kill();

            state.timeline = gsap.timeline();
            state.timeline.to(state.element, {
                scale: 1,
                y: 0,
                opacity: 1,
                duration: 0.4,
                ease: "back.out(1.7)",
                onComplete: () => {
                    typeMessage(message);
                },
            });
        }

        function hideBubble(callback?: () => void): void {
            if (!state.element) return;
            state.isVisible = false;
            state.isTyping = false;
            if (state.timeline) state.timeline.kill();
            if (state.textElement) gsap.killTweensOf(state.textElement);

            state.timeline = gsap.timeline({ onComplete: callback });
            state.timeline.to(state.element, {
                scale: 0.8,
                y: -5,
                opacity: 0,
                duration: 0.3,
                ease: "power2.in",
            });
        }

        function showNextMessage(): void {
            state.currentMessageIndex =
                (state.currentMessageIndex + 1) % messages.length;
            showBubble(messages[state.currentMessageIndex]);

            const message = messages[state.currentMessageIndex];
            const typingDuration = message.length * 0.04 * 1000;
            const readingTime = 2000;

            state.hideTimeout = window.setTimeout(() => {
                hideBubble();
            }, typingDuration + readingTime);
        }

        function handleInteraction(e: Event): void {
            e.stopPropagation();
            if (!state.element) {
                state.element = createBubbleElement();
                container.style.position = "relative";
                container.appendChild(state.element);
            }

            if (state.hideTimeout !== null) clearTimeout(state.hideTimeout);

            if (state.isVisible) {
                hideBubble(() => {
                    showNextMessage();
                });
            } else {
                showBubble(messages[state.currentMessageIndex]);
                const message = messages[state.currentMessageIndex];
                const typingDuration = message.length * 0.04 * 1000;
                const readingTime = 2000;

                state.hideTimeout = window.setTimeout(() => {
                    hideBubble();
                }, typingDuration + readingTime);
            }
        }

        container.addEventListener("pointerdown", handleInteraction);
        svg.addEventListener("pointerdown", handleInteraction);
        container.addEventListener("touchend", (e: TouchEvent) => {
            e.preventDefault();
            handleInteraction(e);
        });

        // --- Mouse Tracking Logic ---
        const handleMouseMove = (e: MouseEvent | PointerEvent) => {
            const rect = container.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            // Calcular diferencia
            const deltaX = e.clientX - centerX;
            const deltaY = e.clientY - centerY;

            // Límites y sensibilidad
            const maxRotation = 15;
            const range = 500; // Sensibilidad del área de influencia

            // Normalizar valores entre -1 y 1
            const normX = Math.max(-1, Math.min(1, deltaX / range));
            const normY = Math.max(-1, Math.min(1, deltaY / range));

            // Aplicar rotación suave con GSAP
            gsap.to(svg, {
                rotateY: normX * maxRotation,
                rotateX: -normY * maxRotation,
                translateX: normX * 8, // Desplazamiento sutil
                duration: 0.0001,
                ease: "power2.out",
                overwrite: "auto",
            });
        };

        const handleMouseLeave = () => {
            gsap.to(svg, {
                rotateY: -10, // Volver a la rotación inicial del CSS
                rotateX: 0,
                translateX: -5,
                duration: 1,
                ease: "elastic.out(1, 0.5)",
            });
        };

        window.addEventListener("pointermove", handleMouseMove);
        // Opcionalmente resetear al salir de la ventana o del contenedor
        container.addEventListener("mouseleave", handleMouseLeave);
    }

    function initAllCharacters() {
        const containers = document.querySelectorAll<HTMLElement>(
            ".bio-image-container",
        );
        containers.forEach((container) => {
            // Evitar doble inicialización si es necesario, aunque con View Transitions
            // el DOM se reemplaza. Pero para estar seguros:
            if (container.dataset.initialized) return;
            container.dataset.initialized = "true";
            initCharacter(container);
        });
    }

    // Inicializar en carga inicial y en cada navegación de Astro
    document.addEventListener("DOMContentLoaded", initAllCharacters);
    document.addEventListener("astro:page-load", initAllCharacters);
</script>
<style>
    .bio-image-container {
        float: right;
        padding: 1rem;
        padding-top: 0;
        border-radius: 12px;
        min-height: 50%;
        width: 140px;

        /* CORRECCIONES CRÍTICAS */
        position: relative;
        z-index: 1;
        overflow: visible;
    }

    .bio-image {
        padding: 0;
        transition: transform 0.3s ease;
        perspective: 100px;
        transform-style: preserve-3d;
        transform: rotate(0deg);
        display: flex;
        justify-content: center;
        align-items: center;
        user-select: none;
        float: none;

        position: relative;
        z-index: 2;
        width: 100%;
        height: 100%;

        /* Animación discreta de entrada (balanceo) */
        transform-origin: bottom center;
        animation: 8s ease-out 0s infinite sway;

        &:hover {
            transform: rotate(0deg);
        }
    }

    @keyframes sway {
        0% {
            transform: rotate(0deg);
        }
        2% {
            transform: rotate(-6deg);
        }
        4% {
            transform: rotate(6deg);
        }
        6% {
            transform: rotate(-3deg);
        }
        8% {
            transform: rotate(2deg);
        }
        10% {
            transform: rotate(0deg);
        }
        100% {
            transform: rotate(0deg);
        }
    }

    svg {
        cursor: pointer;
        user-select: none;
        transition: transform 0.3s ease;
        height: max-content;
        width: 100%;

        transform: rotateY(-10deg) translateX(-5px);
        pointer-events: auto;
        max-width: 100%;

        &:hover {
            transform: rotateY(0deg) scale(1.15) translateX(0px);
        }
    }
</style>
