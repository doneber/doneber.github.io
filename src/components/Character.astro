---
import Avatar from "@/assets/avatar.svg";
import { getI18N } from "@/i18n";

const { currentLocale } = Astro;
const i18n = getI18N({ currentLocale });
const messagesArr = i18n.CHARACTER.MESSAGES;
---

<div class="bio-image-container" data-messages={JSON.stringify(messagesArr)}>
    <div class="bio-image">
        <Avatar />
    </div>
</div>

<script>
    import { gsap } from "gsap";
    import { TextPlugin } from "gsap/TextPlugin";

    gsap.registerPlugin(TextPlugin);

    interface BubbleState {
        element: HTMLDivElement | null;
        textElement: HTMLDivElement | null;
        hideTimeout: number | null;
        currentMessageIndex: number;
        isVisible: boolean;
        timeline: GSAPTimeline | null;
        isTyping: boolean;
    }

    // Función para crear parpadeo natural con GSAP
    function initBlink(): void {
        const eyeLeft = document.getElementById("eye-open-left") as HTMLElement;
        const eyeRight = document.getElementById(
            "eye-open-right",
        ) as HTMLElement;

        if (!eyeLeft || !eyeRight) return;

        function blink(): void {
            const tl = gsap.timeline();

            tl.to([eyeLeft, eyeRight], {
                opacity: 0,
                duration: 0.08,
                ease: "power2.in",
            }).to([eyeLeft, eyeRight], {
                opacity: 1,
                duration: 0.08,
                ease: "power2.out",
            });
        }

        function scheduleBlink(): void {
            const randomDelay = Math.random() * 4000 + 2000;

            gsap.delayedCall(randomDelay / 1000, () => {
                blink();
                scheduleBlink();
            });
        }

        scheduleBlink();
    }

    // Función para mostrar mensajes con GSAP
    function initSpeechBubble(): void {
        const container = document.querySelector(
            ".bio-image-container",
        ) as HTMLElement;
        const svg = document.querySelector(".bio-image svg") as SVGElement;

        if (!container || !svg) return;

        const state: BubbleState = {
            element: null,
            textElement: null,
            hideTimeout: null,
            currentMessageIndex: 0,
            isVisible: false,
            timeline: null,
            isTyping: false,
        };

        const messagesJSON = container.getAttribute("data-messages");
        const messages: string[] = messagesJSON
            ? JSON.parse(messagesJSON)
            : [
                  "¡Hola!",
                  "Estoy seguro que tenía un sombrero",
                  "Hey buuuuddy!",
                  "Ya viste mis proyectos?",
                  "Todo bien?",
                  "¡Qué pasa!",
              ];

        function createBubbleElement(): HTMLDivElement {
            const bubble = document.createElement("div");
            bubble.className = "speech-bubble";

            Object.assign(bubble.style, {
                position: "absolute",
                top: "auto",
                bottom: "100%",
                left: "50%",
                marginBottom: "15px",
                transform: "translateX(-50%)",
                backgroundColor: "#fff",
                color: "#111",
                padding: "12px 18px",
                borderRadius: "18px",
                fontSize: "14px",
                fontWeight: "600",
                boxShadow: "0 4px 12px rgba(0,0,0,0.15)",
                zIndex: "9",
                whiteSpace: "pre-wrap",
                opacity: "0",
                pointerEvents: "none",
                textAlign: "center",
                lineHeight: "1.4",
                maxWidth: "240px",
                minWidth: "120px",
                wordWrap: "break-word",
            } as Partial<CSSStyleDeclaration>);

            // Elemento para el texto que se va a escribir
            const textElement = document.createElement("div");
            textElement.style.minHeight = "1.4em"; // Para evitar saltos de layout
            bubble.appendChild(textElement);

            const tail = document.createElement("div");
            Object.assign(tail.style, {
                content: '""',
                position: "absolute",
                top: "100%",
                left: "50%",
                marginLeft: "-12px",
                width: "0",
                height: "0",
                borderStyle: "solid",
                borderWidth: "12px 12px 0 12px",
                borderColor: "#fff transparent transparent transparent",
                zIndex: "1",
            } as Partial<CSSStyleDeclaration>);

            bubble.appendChild(tail);

            // Configurar estado inicial con GSAP
            gsap.set(bubble, {
                scale: 0,
                y: 10,
                opacity: 0,
            });

            state.textElement = textElement;
            return bubble;
        }

        function typeMessage(message: string): void {
            if (!state.textElement || !state.element) return;

            state.isTyping = true;

            // Limpiar el texto anterior
            state.textElement.textContent = "";

            // Calcular duración basada en la longitud del mensaje
            const baseSpeed = 0.04; // segundos por carácter
            const duration = message.length * baseSpeed;

            // Animar el texto con efecto typewriter
            gsap.to(state.textElement, {
                duration: duration,
                text: {
                    value: message,
                    delimiter: "",
                },
                ease: "none",
                onComplete: () => {
                    state.isTyping = false;
                },
            });
        }

        function showBubble(message: string): void {
            if (!state.element) return;

            state.isVisible = true;

            // Matar animación anterior si existe
            if (state.timeline) {
                state.timeline.kill();
            }

            // Timeline para la entrada del bocadillo
            state.timeline = gsap.timeline();

            // Primero aparece el bocadillo
            state.timeline.to(state.element, {
                scale: 1,
                y: 0,
                opacity: 1,
                duration: 0.4,
                ease: "back.out(1.7)",
                onComplete: () => {
                    // Después de que aparece, empieza el efecto typewriter
                    typeMessage(message);
                },
            });
        }

        function hideBubble(callback?: () => void): void {
            if (!state.element) return;

            state.isVisible = false;
            state.isTyping = false;

            // Matar animación anterior si existe
            if (state.timeline) {
                state.timeline.kill();
            }

            // Matar animación de texto si existe
            if (state.textElement) {
                gsap.killTweensOf(state.textElement);
            }

            // Animación de salida con GSAP
            state.timeline = gsap.timeline({
                onComplete: callback,
            });

            state.timeline.to(state.element, {
                scale: 0.8,
                y: -5,
                opacity: 0,
                duration: 0.3,
                ease: "power2.in",
            });
        }

        function showNextMessage(): void {
            state.currentMessageIndex =
                (state.currentMessageIndex + 1) % messages.length;

            showBubble(messages[state.currentMessageIndex]);

            // Calcular tiempo de espera dinámico basado en longitud del mensaje
            const message = messages[state.currentMessageIndex];
            const typingDuration = message.length * 0.04 * 1000; // convertir a ms
            const readingTime = 2000; // tiempo para leer después de escribir

            state.hideTimeout = window.setTimeout(() => {
                hideBubble();
            }, typingDuration + readingTime);
        }

        function handleInteraction(e: Event): void {
            e.stopPropagation();

            // Crear bubble si no existe
            if (!state.element) {
                state.element = createBubbleElement();
                container.style.position = "relative";
                container.appendChild(state.element);
            }

            // Limpiar timeout anterior
            if (state.hideTimeout !== null) {
                clearTimeout(state.hideTimeout);
            }

            if (state.isVisible) {
                // Si está escribiendo, cancelar y cambiar al siguiente
                hideBubble(() => {
                    showNextMessage();
                });
            } else {
                showBubble(messages[state.currentMessageIndex]);

                // Calcular tiempo de espera dinámico
                const message = messages[state.currentMessageIndex];
                const typingDuration = message.length * 0.04 * 1000;
                const readingTime = 2000;

                state.hideTimeout = window.setTimeout(() => {
                    hideBubble();
                }, typingDuration + readingTime);
            }
        }

        // Event listeners
        container.addEventListener("pointerdown", handleInteraction);
        svg.addEventListener("pointerdown", handleInteraction);

        container.addEventListener("touchend", (e: TouchEvent) => {
            e.preventDefault();
            handleInteraction(e);
        });
    }

    // Inicializar cuando el DOM esté listo
    function init(): void {
        initBlink();
        initSpeechBubble();
    }

    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
    } else {
        init();
    }
</script>
<style>
    .bio-image-container {
        float: right;
        padding: 1rem;
        padding-top: 0;
        border-radius: 12px;
        min-height: 50%;
        width: 140px;

        /* CORRECCIONES CRÍTICAS */
        position: relative;
        z-index: 1;
        overflow: visible;
    }

    .bio-image {
        padding: 0;
        transition: transform 0.3s ease;
        perspective: 100px;
        transform-style: preserve-3d;
        transform: rotate(0deg);
        display: flex;
        justify-content: center;
        align-items: center;
        user-select: none;
        float: none;

        position: relative;
        z-index: 2;
        width: 100%;
        height: 100%;

        /* Animación discreta de entrada (balanceo) */
        transform-origin: bottom center;
        animation: 8s ease-out 0s infinite sway;

        &:hover {
            transform: rotate(0deg);
        }
    }

    @keyframes sway {
        0% {
            transform: rotate(0deg);
        }
        2% {
            transform: rotate(-6deg);
        }
        4% {
            transform: rotate(6deg);
        }
        6% {
            transform: rotate(-3deg);
        }
        8% {
            transform: rotate(2deg);
        }
        10% {
            transform: rotate(0deg);
        }
        100% {
            transform: rotate(0deg);
        }
    }

    svg {
        cursor: pointer;
        user-select: none;
        transition: transform 0.3s ease;
        height: max-content;
        width: 100%;

        transform: rotateY(-10deg) translateX(-5px);
        pointer-events: auto;
        max-width: 100%;

        &:hover {
            transform: rotateY(0deg) scale(1.05) translateX(0px);
        }
    }
</style>
